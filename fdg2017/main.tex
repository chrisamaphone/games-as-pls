\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables

\usepackage{proof}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
% \setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
% \acmDOI{10.475/123_4}

% ISBN
% \acmISBN{123-4567-24-567/08/06}

%Conference
% \acmConference[WOODSTOCK'97]{ACM Woodstock conference}{July 1997}{El
%  Paso, Texas USA} 
% \acmYear{1997}
% \copyrightyear{2016}

% \acmPrice{15.00}


\begin{document}
\title{Languages of Play}
\subtitle{Towards semantic foundations for game interfaces}


%% Double blind review
% \author{Chris Martens}
% \affiliation{%
%   \institution{North Carolina State University}
%   \city{Raleigh} 
%   \state{NC} 
% }
% \email{martens@csc.ncsu.edu}
% 
% \author{Matthew Hammer}
% \affiliation{%
%   \institution{University of Colorado, Boulder}
%   \city{Boulder}
%   \state{CO}
% }
% \email{XXX@XXX.edu}


\begin{abstract}
Abstract goes here. A full paper's maximum length is 10 pages; a short
paper's is 6 pages. Track: probably Game Design and Development.
\end{abstract}


\keywords{games, programming languages, formal methods}

\maketitle

\section{Introduction}

The field of player modeling studies how players traverse a game space,
examining the interaction between the rules of the underlying system and
the choices made by the player. One recognizes that we need to construct
detailed models of player cognition: while a game as a self-contained
entity can allow us to learn about its mechanics and properties as a formal
system, we cannot understand the {\em dynamics} of that system unless we
also account for the human half of the equation.

What often goes missing in such a discussion, however, is the {\em
interface} between the two. Crawford (XXX) defined interactivity in games
as their ability to carry out a conversation with a player, including
listening, processing, and responding, identifying the importance of all
three to the overall experience. Cardona-Rivera and Young (XXX cite)
later proposed a more detailed conceptual framework following the slogan
{\em games as conversation}, emphasizing that play is a two-way street: a
game provides affordances for action, a player takes action based on those
affordances, and the game responds in turn with feedback that develops the
player's mental model for the behavior of the system implied by the
interaction as a whole. And, just as the field of film studies has
developed a notion of {\em vocabulary} that visual storytellers use to
communicate with audiences, scholars have studied the vocabulary and
representational conventions of games (XXX cite something re games
literacy?) that designers employ to communicate with players, e.g. a
horizontal green bar floating above an avatar representing its health,
inviting an attack; a question mark labeling an object as an accessible
reward or power-up; or a crack in an otherwise solid-seeming object
suggesting it might be breakable.

We have recognized that a symbolic, discretized and representational
approach to looking at this kind of design language has value. But in the
context of interactibity, it would seem that we should account for another
component: the analog to {\em design language} employed by the
player. How does the player communicate their intent, and how does a
digital game recognize this intent?

Clearly they use some kind of language, but since the constraints on what
language they may use are wholly determined by a piece of software (the
game interface), we argue that this language has more in common with a {\em
programming language} (loosely defined as a formal language whose meaning
is fully grounded in a computational system) than a natural language. We
argue that conceptualzing player communication in terms of hardware
interactions (button presses, mouse clicks) is too {\em low-level} of an
approach to meaningfully study interaction, and that instead we should make
sense of these interactions on a {\em per-game} basis in terms of the {\em
meaning} with which a game imbues these interactions. 

Accordingly, each game provides a player with a unique formal language,
termed ``programming language'' (though it may have a great deal in common
with other games' languages) to express themselves. While some researchers
have recognized interaction vocabularies common to certain types of games,
their conclusion was to codify these conventions as a {\em single}
programming language (VGDL, XXX cite), misleadingly positioned as though it
could represent all (or a broad category) of games in a high-level way.
We suggest that instead, the landscape of game representations and player
affordances is as varied as the landscape of programming languages, and an
adequate computational framework should be one that can accommodate the
encoding of many such languages, such as a {\em logical framework} (XXX
cite Twelf or something).

What is to be gained by the game-interfaces-as-programming languages analogy?

The programming languages (PL) community has a long and deep history of
assigning mathematically formal semantics to languages and analyzing those
semantics. As games researchers become more interested in the emergent
consequences of the systems they assemble, the tools of PL theory have a
lot to offer. For example, PL theory provides an account of how to relate
meaning in a {\em low level} representation (such as assembly language, or
on the games side, hardware-level interactions) to meaning in a {\em
high-level} language (such as a language like Java or a game's state
space), allowing us to draw abstraction boundaries and consider system
components in compositional terms. For example, we can consider what it
means to have a game with the same {\em internal mechanics} (or what Salen
and Zimmerman (XXX) call {\em constiutative rules}) but distinct interface,
comparing the meaning of these interfaces on formal terms.

% In Salen and Zimmerman (XXX cite) terms,
% PL theory can help us formalize the {\em constituative mechanics} of a
% game's interface so that we may consider distinct {\em operational rules} 
% that interface with them. 

% XXX example: parser vs. hypertext interactive fiction?
%
% Parser:
%   Interface:
%     >
%   Recognized utterances - contextual:
%    > <verb> <noun>
%    > <verb>
%    > <verb> <noun> <preposition> <noun>
%
% Hypertext:
%   Interface: contextual, e.g.
%     [[go north]] or [[go south]] or [[take sword]] ?
%   Recognized utterances:
%     (link clicks) - 1 dimensional, contextual, ambiguous


Furthermore, by considering a player's language of expression as an object
of study in its own right, we center her as a co-designer of the experience
afforded by a game. When we treat a player's interactions as not simply an
arbitrary sequence of button presses that advances and reveals the
designer's intent, but instead as its own distinct {\em voice} that a game
system must listen and respond to, we enable the player to {\em co-create}
with the system, potentially developing stronger systems thinking skills in
the player, eliciting deeper understanding and even deeper emotional
investment.

In the remainder of the paper, we concretize the analogy by introducing the
components of a theoretical account of a programming language (syntax, type
system, and operational semantics) and its analog in a game. We walk
through an example to illustrate how to think about a game in terms of its
language-like affordances, and we demonstrate the payoff of this line of
thought by extending the metaphor to account for {\em player skills} as
``programs,'' effectively representing mental models for how to accomplish
some task in terms of the game's linguistic constructs.


\section{Related Work}

AI action languages (planning, event calc, etc.); general game AI frameworks

FRP? Other PL stuff; embedded DSLs?

PlaySpecs

Hazel

\section{A Framework}

  % (that table from the doc should go here)

  % Background: Syntax, type systems, and operational semantics

  In the formal study of a programming langugage, one may define a language
  in three parts: syntax, type system, and operational semantics.
  \begin{itemize}
    \item The {\em syntax} is written in the form of a (usually)
      context-free grammar describing the allowable expressions.
    \item A {\em type system} further refines the set of allowable
      expressions into a set of {\em meaningful} expressions, and provides
      a mapping between an expression and an approximation of its meaning.
      Type systems are usually designed in conjunction with the operational
      semantics to have the property that {\em well-typed programs don't go
      wrong}, i.e., every expression assigned a meaning by the type system
      should have a well-defined runtime behavior.
    \item An {\em operational semantics} defines how runnable programs
      (e.g. a function applied to an argument) {\em reduce} to values. This
      part of the definition describes how actual computation takes place
      when programs in the language are run. It is important to note that
      the operational semantics need not reflect the actual {\em
      implementation} of the language, nor is it specific to a ``compiled''
      versus ``interpreted'' understanding of the language: it is simply a
      mathematical specification for how any compiler or interpreter for
      the language should behave.
  \end{itemize}
  
  Providing a formal language definition in programming languages research
  has several purposes. One is that it enables researchers to explore
  and prove formal properties of their language, such as {\em well-typed
  programs don't go wrong}, or in a language for concurrency, a property
  like deadlock freedom. However, an even more crucial advantage of a
  language specification is not mathematical rigor but human capacity to do
  science. A language definition is a {\em specification}, similar to an
  application programmer interface (API) or an IEEE standard: it describes
  an unambiguous interface to the language along an {\em abstraction
  boundary} that other human beings may access, understand, and implement,
  without knowing the internals of a language implementation.  It is a
  necessary component of reproducibility of research, and it allows
  researchers to build on each other's work. We believe that an embrace of
  the formal specification in games research can play a similarly important
  function.

  Having provided loose definitions of these terms, we now wish to draw out
  the analogy between a {\em language} specification and a {\em game}
  specification. To treat a game in this manner, we wish to consider player
  affordances and actions, as well as their behavior (mechanics) in the
  context of the game's running environment. We summarize the components of
  this correspondence in Table~\ref{tab:correspondence}.

  \begin{table}
  \begin{tabular}{ll}
    PL concept & Game concept\\
    \hline
    Syntax & Recognized player actions \\
    Type system & Meaningful player actions \\
    Operational semantics & Game mechanics \\
    Runtime store & Game world \\
    Normalized programs & Play traces 
  \end{tabular}
  \label{tab:correspondence}
  \end{table}

  (XXX turn into sentences)
  Running example: moving through a discrete set ofrooms,
  acquiring objects placed in those rooms.

  \subsection{Player actions as syntax}

  Should be context free; recognizable by a parser; define well-formed
  expressions by the player
  
  Possibilities for movement:
  pressing a directional arrow;
  typing a direction;
  moving the mouse or joystick

  Possibilities for taking an item:
  pressing a designated button;
  typing ``\verb/take <item>/'';
  colliding with the item

  BNF for interface 1:\\
  \verb/move <dir> | collect/

  BNF for interface 2:\\
  \verb/go <dir> | take <thing>/\\
  n.b. larger set of allowable utterances; meaning is less contextual
  (easier to infer by itself what parts of the game state it will depend
  on)

  BNF for interface 3:\\
  \verb/move <dir>/\\
  n.b. much {\em more} contextual; it's impossible to infer what each
  action will ``do'' in the game and which parts of the game environment it
  depends on

  Additive vs. subtractive affordances:

  Just like with the rest of a game's rules, its language of play has both
  additive and subtractive properties: it provides the menu of options for
  what types of things are {\em permissible}, i.e. likely to result in
  meaningful interaction with the game system, but it also establishes
  which utterances are {\em disallowed}, i.e. that it is not meaningful to
  say ``take'' without providing an object to the command.

  ... is the grammar for a blank text field that or is it just any typed
  string, and the type system what enforces the grammatical structure?
  (XXX)

  \subsection{Structured affordances as type systems}
  
  Whether an utterance is {\em meaningful} or not will depend on
  the runtime game state, and is a distinct question from whether it is
  well-formed. For example, whether or not we can {\em take
  flask} depends on whether the flask is present, or indeed whether a {\em
  flask} is even a recognized game object. But unless ill-formed intents can be
  recognized a priori (such as: if we know the complete set of possible
  game objects ahead of time and can reject commands that refer to entities
  outside of that set), we must treat this command as well-formed {\em
  syntax} and relegate its failure to integrate with the runtime game
  environment to the {\em mechanics} (operational semantics).

  However, we can rule out an approximation of ill-formed utterances using
  type systems. For example, if we know the ...
  (only take portable things, only talk to characters, etc - could be
  specified at the grammar level)
  
  Providing the player with {\em only the option of saying} those
  utterances that ``make sense'' in this regard corresponds to a strong
  static type system: e.g. choice-based interface to parser-based commands

  \subsection{Mechanics as operational semantics}

  To characterize mechanics, we will also need an account of expressions
  permissible in the game's language (e.g. display a room, make a sound,
  make an object disappear, etc. --- things more commonly accounted for in
  formal game description languages). 

  \newcommand{\stepsto}{\rightsquigarrow}

  Judgment: $\sigma; e_p \stepsto \sigma'; e_g$ \\
  where $e_p$ is a player expression and $e_g$ is a game expression, and
  $\sigma$ and $\sigma'$ are game states. This judgment should be read:
  ``Under state $\sigma$, the game responds to player action $e_p$ by
  changing to state $\sigma'$ and conveying information $e_g$.''

  Mechanics of interface 1:

  \[
    \infer{
      \sigma, at(R); PLAYER: move<dir> \stepsto \sigma, at(R'); GAME:
      display(R')
    }
    {
      indir(dir, R, R') \in \sigma
    }
  \]

  \subsection{Game environment as external runtime}

  \subsection{Play traces as (normalized) programs}
  
  Argument for having a syntactically-well-founded structured term for a
  play trace

  
\section{Example}

Stardew Valley

\section{Player skills as programs}

And skill-building as iterative program construction

Mention BOTS

Nondeterminism, protocols

\section{Discussion}

  What this enables:
  \begin{itemize}
  \item Scripting languages for games, for free
  \item Co-creative interfaces and collaborative play, a la MUDs/ZZT
  \item Reasoning about/analyzing games and possible skill trees
  \end{itemize}

  A single ``video game description language'' is a misleading direction to
  take a formal understanding of games, because games as expressive forms
  are as diverse as programming languages.

  Instead, we can imagine meta-frameworks c.f. logical frameworks for
  encoding PLs and specifying their meaning.

  Future work: try to draw further analogies. Better REPLs for PLs? 

\section{Conclusion}

  Summary of contributions (new ideas, why they matter)

\begin{acks}
  acknowledgements
\end{acks}

% \bibliographystyle{ACM-Reference-Format}
% \bibliography{sigproc} 

\end{document}
